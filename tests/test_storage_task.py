"""Tests for task storage operations."""

import pytest
import sqlite3
import uuid  # For generating IDs
from pm.models import Project, Task, Subtask, Note  # Remove MetadataValue import
from pm.storage import init_db
# Needed to create projects for tasks
from pm.storage.project import create_project
from pm.storage.task import create_task, get_task, get_task_by_slug, list_tasks, delete_task, add_task_dependency
from pm.storage.subtask import create_subtask  # Need subtask creation
from pm.storage.note import create_note  # Need note creation
from pm.storage.metadata import update_task_metadata  # Correct function name
from pm.core.utils import generate_slug


@pytest.fixture
def db_connection(tmp_path):
    """Fixture providing a clean database connection for each test."""
    db_path = tmp_path / "test.db"
    conn = init_db(str(db_path))  # Ensure db_path is string
    yield conn
    conn.close()


def test_task_creation_storage(db_connection):
    """Test creating and retrieving a task via storage functions."""
    # Setup: Create a project first
    project_data = Project(id="test-project-for-task",
                           name="Test Project for Task")
    project = create_project(db_connection, project_data)

    # Create the task
    # Note: Slug is now optional in model, generated by create_task
    task_data = Task(
        id="test-task-storage",
        project_id="test-project-for-task",
        name="Test Task Storage"
    )
    created_task = create_task(db_connection, task_data)
    assert created_task.id == "test-task-storage"
    assert created_task.project_id == "test-project-for-task"
    assert created_task.slug == "test-task-storage"  # Verify generated slug

    # Retrieve and verify
    retrieved_task = get_task(db_connection, "test-task-storage")
    assert retrieved_task.id == "test-task-storage"
    assert retrieved_task.project_id == "test-project-for-task"
    assert retrieved_task.slug == "test-task-storage"  # Verify slug on retrieval


def test_task_slug_storage(db_connection):
    """Test task slug generation, uniqueness (within project), and retrieval via storage."""
    # Create two projects
    proj_a_data = Project(id="proj-a", name="Project A")
    proj_a = create_project(db_connection, proj_a_data)
    proj_b_data = Project(id="proj-b", name="Project B")
    proj_b = create_project(db_connection, proj_b_data)

    # Create task 1 in Project A
    task1a_data = Task(id="task-1a", project_id="proj-a", name="My Task")
    task1a = create_task(db_connection, task1a_data)
    expected_slug1a = "my-task"
    assert task1a.slug == expected_slug1a

    # Retrieve task 1a by ID and check slug
    retrieved1a_by_id = get_task(db_connection, "task-1a")
    assert retrieved1a_by_id.slug == expected_slug1a

    # Retrieve task 1a by slug
    retrieved1a_by_slug = get_task_by_slug(
        db_connection, "proj-a", expected_slug1a)
    assert retrieved1a_by_slug.id == "task-1a"
    assert retrieved1a_by_slug.slug == expected_slug1a

    # Create task 2 in Project A with the same name (collision)
    task2a_data = Task(id="task-2a", project_id="proj-a", name="My Task")
    task2a = create_task(db_connection, task2a_data)
    expected_slug2a = "my-task-1"  # Expect collision handling within project
    assert task2a.slug == expected_slug2a

    # Retrieve task 2a by slug
    retrieved2a_by_slug = get_task_by_slug(
        db_connection, "proj-a", expected_slug2a)
    assert retrieved2a_by_slug.id == "task-2a"
    assert retrieved2a_by_slug.slug == expected_slug2a

    # Create task 3 in Project B with the same name (no collision expected)
    task3b_data = Task(id="task-3b", project_id="proj-b", name="My Task")
    task3b = create_task(db_connection, task3b_data)
    expected_slug3b = "my-task"  # Same name, different project
    assert task3b.slug == expected_slug3b

    # Retrieve task 3b by slug
    retrieved3b_by_slug = get_task_by_slug(
        db_connection, "proj-b", expected_slug3b)
    assert retrieved3b_by_slug.id == "task-3b"
    assert retrieved3b_by_slug.slug == expected_slug3b

    # Test listing tasks for Project A includes slugs
    tasks_a = list_tasks(db_connection, project_id="proj-a")
    task_map_a = {t.id: t for t in tasks_a}
    assert task_map_a["task-1a"].slug == expected_slug1a
    assert task_map_a["task-2a"].slug == expected_slug2a

    # Test listing tasks for Project B includes slugs
    tasks_b = list_tasks(db_connection, project_id="proj-b")
    assert len(tasks_b) == 1
    assert tasks_b[0].id == "task-3b"
    assert tasks_b[0].slug == expected_slug3b

    # Test retrieval by non-existent slug
    assert get_task_by_slug(db_connection, "proj-a",
                            "non-existent-slug") is None
    # Test retrieval by valid slug but wrong project
    # Use expected_slug2a ('my-task-1') which only exists in project A
    assert get_task_by_slug(db_connection, "proj-b", expected_slug2a) is None


def test_task_deletion_cascades(db_connection):
    """Test that deleting a task deletes associated subtasks, notes, metadata, and dependencies."""
    # 1. Setup Project and Tasks
    project_id = str(uuid.uuid4())
    project_data = Project(id=project_id, name="Project For Task Deletion")
    create_project(db_connection, project_data)

    task_id_to_delete = str(uuid.uuid4())
    task_to_delete_data = Task(
        id=task_id_to_delete, project_id=project_id, name="Task To Delete")
    create_task(db_connection, task_to_delete_data)

    dependency_task_id = str(uuid.uuid4())
    dependency_task_data = Task(
        id=dependency_task_id, project_id=project_id, name="Dependency Task")
    create_task(db_connection, dependency_task_data)

    # 2. Create Associated Data
    # Subtask
    subtask_id = str(uuid.uuid4())
    subtask_data = Subtask(
        id=subtask_id, task_id=task_id_to_delete, name="Subtask To Delete")
    create_subtask(db_connection, subtask_data)

    # Note
    note_id = str(uuid.uuid4())
    note_data = Note(id=note_id, entity_type='task',
                     entity_id=task_id_to_delete, content="Task note")
    create_note(db_connection, note_data)

    # Metadata
    metadata_key = "test_key"
    metadata_value = "test_value"  # Pass the raw value
    update_task_metadata(db_connection, task_id_to_delete,  # Use correct function name
                         metadata_key, metadata_value)  # Call with raw value

    # Dependency (task_to_delete depends on dependency_task)
    add_task_dependency(db_connection, task_id_to_delete, dependency_task_id)
    # Dependency (dependency_task depends on task_to_delete) - REMOVED to avoid circular dependency error
    # add_task_dependency(db_connection, dependency_task_id, task_id_to_delete)

    # Verify initial state
    assert get_task(db_connection, task_id_to_delete) is not None
    assert db_connection.execute(
        "SELECT COUNT(*) FROM subtasks WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 1
    assert db_connection.execute(
        "SELECT COUNT(*) FROM notes WHERE entity_type = 'task' AND entity_id = ?", (task_id_to_delete,)).fetchone()[0] == 1
    assert db_connection.execute(
        "SELECT COUNT(*) FROM task_metadata WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 1
    assert db_connection.execute("SELECT COUNT(*) FROM task_dependencies WHERE task_id = ? OR dependency_id = ?",
                                 # Only one dependency link now
                                 (task_id_to_delete, task_id_to_delete)).fetchone()[0] == 1

    # 3. Delete Task
    deleted = delete_task(db_connection, task_id_to_delete)
    assert deleted is True

    # 4. Verify deletion
    assert get_task(db_connection, task_id_to_delete) is None
    assert db_connection.execute(
        "SELECT COUNT(*) FROM subtasks WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 0
    assert db_connection.execute(
        "SELECT COUNT(*) FROM notes WHERE entity_type = 'task' AND entity_id = ?", (task_id_to_delete,)).fetchone()[0] == 0
    assert db_connection.execute(
        "SELECT COUNT(*) FROM task_metadata WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 0
    # Check dependencies involving the deleted task are gone
    assert db_connection.execute("SELECT COUNT(*) FROM task_dependencies WHERE task_id = ? OR dependency_id = ?",
                                 (task_id_to_delete, task_id_to_delete)).fetchone()[0] == 0
    # Ensure the other task still exists
    assert get_task(db_connection, dependency_task_id) is not None
