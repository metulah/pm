"""Project management commands."""

import uuid
from typing import Optional
import click
import textwrap  # Import textwrap

from ..models import Project, TaskStatus  # Import TaskStatus
# Removed sys import again if present
from ..storage import (
    create_project, get_project, update_project,
    delete_project, list_projects, ProjectNotEmptyError
)
from ..core.types import ProjectStatus  # Import ProjectStatus
# Import resolver, task_list, and get_db_connection
from .base import cli, get_db_connection, format_output, resolve_project_identifier, read_content_from_argument
from .task import task_list  # Import task_list


@cli.group()
def project():
    """Manage projects."""
    pass


@project.command("create")
@click.option("--name", required=True, help="Project name")
@click.option("--description", help="Project description (or @filepath to read from file).", callback=read_content_from_argument)
@click.option("--status", type=click.Choice([s.value for s in ProjectStatus]),
              # Changed default and simplified help
              default=ProjectStatus.PROSPECTIVE.value, help="Initial project status (defaults to PROSPECTIVE)")
@click.pass_context  # Need context to get format
# Add status to signature
def project_create(ctx, name: str, description: Optional[str], status: str):
    """Create a new project."""
    conn = get_db_connection()
    try:
        # Slug is generated by create_project, so it's not passed here
        project_data = Project(id=str(uuid.uuid4()), name=name,
                               description=description,
                               status=ProjectStatus(status))
        # create_project now returns the full object with slug
        project = create_project(conn, project_data)
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        # Pass format and object
        click.echo(format_output(output_format, "success", project))
    except Exception as e:
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        click.echo(format_output(output_format, "error",
                   message=str(e)))  # Use format_output
    finally:
        conn.close()


@project.command("list")
# Add --id flag
@click.option('--id', 'show_id', is_flag=True, default=False, help='Show the full ID column in text format.')
# Add --completed flag
@click.option('--completed', 'include_completed', is_flag=True, default=False, help='Include completed projects in the list.')
# Add --description flag
@click.option('--description', 'show_description', is_flag=True, default=False, help='Show the full description column in text format.')
# Add --archived flag
# Corrected help text
@click.option('--archived', 'include_archived', is_flag=True, default=False, help='Include archived projects in the list.')
@click.option('--prospective', 'include_prospective', is_flag=True, default=False, help='Include prospective projects in the list.')
# Add --cancelled flag
@click.option('--cancelled', 'include_cancelled', is_flag=True, default=False, help='Include cancelled projects in the list.')
# Add --all flag
@click.option('--all', 'include_all', is_flag=True, default=False, help='Include projects of all statuses (overrides other status flags).')
@click.pass_context
# Add include_all to signature
def project_list(ctx, show_id: bool, include_completed: bool, show_description: bool, include_archived: bool, include_cancelled: bool, include_prospective: bool, include_all: bool):
    """List all projects."""
    conn = get_db_connection()
    try:
        # print("DEBUG[project_list]: 1 - Getting projects", file=sys.stderr) # Removed debug

        # If --all is specified, override individual flags
        if include_all:
            include_completed = True
            include_archived = True
            include_cancelled = True
            include_prospective = True
            # Note: ACTIVE projects are included by default unless filtered out

        # Pass flags to storage function
        projects = list_projects(conn, include_completed=include_completed,
                                 include_archived=include_archived,
                                 include_cancelled=include_cancelled,
                                 include_prospective=include_prospective)
        # print(f"DEBUG[project_list]: 2 - Got {len(projects)} projects", file=sys.stderr) # Removed debug
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        # Pass the show_id flag to the context for the formatter
        ctx.obj['SHOW_ID'] = show_id
        ctx.obj['SHOW_DESCRIPTION'] = show_description  # Pass flag to context
        # print(f"DEBUG[project_list]: 3 - Format is '{output_format}'", file=sys.stderr) # Removed debug
        # Pass format and list of objects
        formatted_output = format_output(output_format, "success", projects)
        # print("DEBUG[project_list]: 4 - Formatting successful", file=sys.stderr) # Removed debug
        click.echo(formatted_output)
    except Exception as e:
        # print(f"DEBUG[project_list]: 5 - Caught Exception: {repr(e)}", file=sys.stderr) # Removed debug
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        # print(f"DEBUG[project_list]: 6 - Formatting error message", file=sys.stderr) # Removed debug
        click.echo(format_output(output_format, "error",
                   message=str(e)))  # Use format_output
    finally:
        conn.close()


@project.command("show")
@click.argument("identifier")  # Changed name from project_id to identifier
@click.pass_context
def project_show(ctx, identifier: str):
    """Show project details."""
    conn = get_db_connection()
    try:
        project = resolve_project_identifier(conn, identifier)  # Use resolver
        output_format = ctx.obj.get('FORMAT', 'json')
        # Resolver raises error if not found, so we assume project exists here
        click.echo(format_output(output_format, "success", project))
    except Exception as e:
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        # print(f"DEBUG[project_show_except]: Caught Exception: type={type(e)}, repr='{repr(e)}', str='{str(e)}'", file=sys.stderr) # Removed debug
        click.echo(format_output(output_format, "error",
                   message=str(e)))  # Use format_output
    finally:
        conn.close()


@project.command("update")
@click.argument("identifier")  # Changed name from project_id to identifier
@click.option("--name", help="New project name")
@click.option("--description", help="New project description (or @filepath to read from file).", callback=read_content_from_argument)
@click.option("--status", type=click.Choice([s.value for s in ProjectStatus]),  # Updated choices
              help="New project status (ACTIVE, PROSPECTIVE, COMPLETED, ARCHIVED, CANCELLED)")
@click.pass_context
def project_update(ctx, identifier: str, name: Optional[str], description: Optional[str], status: Optional[str]):
    """Update a project."""
    conn = get_db_connection()
    try:
        # Resolve identifier first to get the project ID
        project_to_update = resolve_project_identifier(conn, identifier)
        project_id = project_to_update.id

        kwargs = {}
        if name is not None:
            kwargs["name"] = name
        if description is not None:
            kwargs["description"] = description
        if status is not None:
            kwargs["status"] = status

        # Call update_project with the resolved ID
        project = update_project(conn, project_id, **kwargs)
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        # update_project returns the updated project object (or None if ID was invalid, though resolver should prevent this)
        # Resolver raises error if not found, so we assume project exists here
        click.echo(format_output(output_format, "success", project))
        # If status was explicitly updated, show reminder
        if status is not None:
            reminder = textwrap.dedent("""

               Reminder: Project status updated. Consider the following:
               - Ensure all related tasks are appropriately status'd (e.g., COMPLETED).
               - Update overall project documentation/notes if needed.
               - Consider archiving related artifacts if project is COMPLETED/ARCHIVED.
            """)
            click.echo(reminder, err=True)
    except ValueError as e:  # Catch specific validation errors
        click.echo(f"Error: {e}", err=True)
        ctx.exit(1)  # Exit with non-zero status
    except Exception as e:  # Keep generic handler for other errors
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        click.echo(format_output(output_format, "error",
                   message=str(e)))  # Use format_output
    finally:
        conn.close()


@project.command("delete")
@click.argument("identifier")  # Changed name from project_id to identifier
@click.option('--force', is_flag=True, default=False, help='REQUIRED: Confirm irreversible deletion of project and associated data.')
@click.pass_context
def project_delete(ctx, identifier: str, force: bool):
    """Delete a project."""
    conn = get_db_connection()
    try:
        # Resolve identifier first to get the project ID
        project_to_delete = resolve_project_identifier(conn, identifier)
        project_id = project_to_delete.id

        # Check for --force flag before proceeding
        if not force:
            raise click.UsageError(
                "Deleting a project is irreversible and will remove all associated tasks, notes, etc. "
                "Use the --force flag to confirm."
            )

        # Call delete_project with the resolved ID (force=True is implied by reaching here)
        success = delete_project(conn, project_id, force=True)
        output_format = ctx.obj.get('FORMAT', 'json')
        # Resolver raises error if not found, delete_project returns bool based on deletion success
        # We rely on delete_project's return value and ProjectNotEmptyError
        if success:
            click.echo(format_output(output_format, "success",
                       message=f"Project '{identifier}' deleted"))
        else:
            # This case should ideally not be reached if resolver works and delete_project raises errors correctly
            click.echo(format_output(output_format, "error",
                       message=f"Failed to delete project '{identifier}'"))

    except ProjectNotEmptyError as e:  # Catch the specific error
        # Get format from context
        output_format = ctx.obj.get('FORMAT', 'json')
        # Original message is fine, as this error should ideally only be raised
        # by the storage layer if force=True was passed but something went wrong.
        # The CLI layer prevents calling storage without force.
        click.echo(format_output(output_format, "error", message=str(e)))
    except click.ClickException:
        # Let Click handle its own exceptions (like UsageError)
        # This ensures correct exit codes and stderr output for CLI errors
        raise
    except Exception as e:  # Catch other unexpected errors
        output_format = ctx.obj.get('FORMAT', 'json')
        click.echo(format_output(output_format, "error",
                   message=f"An unexpected error occurred: {e}"))
    finally:
        conn.close()


# Add the new 'tasks' command
@project.command("tasks")
@click.argument("identifier")  # Project identifier (ID or slug)
@click.option("--status", type=click.Choice([s.value for s in TaskStatus]),
              help="Filter by task status")
@click.option('--id', 'show_id', is_flag=True, default=False, help='Show the full ID column in text format.')
@click.option('--completed', 'include_completed', is_flag=True, default=False, help='Include completed tasks in the list (unless --status is used).')
@click.option('--description', 'show_description', is_flag=True, default=False, help='Show the full description column in text format.')
@click.option('--inactive', 'include_inactive_project_tasks', is_flag=True, default=False, help='Include tasks from non-ACTIVE projects.')
@click.pass_context
def project_tasks(ctx, identifier: str, status: Optional[str], show_id: bool, include_completed: bool, show_description: bool, include_inactive_project_tasks: bool):
    """List tasks for a specific project."""
    conn = None  # Initialize conn to None
    try:
        conn = get_db_connection()
        # Step 1: Resolve project identifier FIRST.
        # This raises click.UsageError if not found, which Click handles by exiting non-zero.
        # This line validates the project
        resolve_project_identifier(conn, identifier)

        # Step 2: If resolution succeeded, invoke task_list.
        # task_list handles its own errors internally for other issues.
        ctx.invoke(task_list, project=identifier, status=status, show_id=show_id,
                   include_completed=include_completed, show_description=show_description,
                   include_inactive_project_tasks=include_inactive_project_tasks)

    except click.ClickException:
        # Let Click handle its own exceptions (like UsageError from resolver)
        raise  # Re-raise for Click to handle
    except Exception as e:
        # Handle potential unexpected errors *during* task_list invocation
        output_format = ctx.obj.get('FORMAT', 'json')
        click.echo(format_output(output_format, "error",
                   message=f"Unexpected error listing tasks for project '{identifier}': {e}"))
        ctx.exit(1)  # Ensure exit with non-zero code
    finally:
        # Ensure connection is closed even if resolver fails or invoke fails
        if conn:
            conn.close()
